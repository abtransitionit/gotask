package onpm

import (
	"errors"
	"fmt"
	"sync"

	"github.com/abtransitionit/gocore/logx"
	lfile "github.com/abtransitionit/golinux/mock/file"
	lonpm "github.com/abtransitionit/golinux/mock/onpm"
	"gopkg.in/yaml.v3"
)

// Description: add native os package repositories to a set of node
//
// Notes:
// - a node is a remote VM, the localhost, a container or a remote container
// - a host is a node from which the ssh command is executed
func AddRepo(phaseName, hostName string, paramList [][]any, logger logx.Logger) (bool, error) {

	// logger.Debugf("paramList: %v", paramList)
	// 1 - extract parameters
	// 11 - repository:list
	if len(paramList) < 1 || len(paramList[0]) == 0 {
		return false, fmt.Errorf("host: %s > list of repo not provided in paramList", hostName)
	}
	raw := paramList[0]

	b, err := yaml.Marshal(raw)
	if err != nil {
		return false, err
	}
	repoList, err := lfile.GetVarStruct[lonpm.RepoSlice](fmt.Sprint(string(b)))
	if err != nil {
		logger.Errorf("%v", err)
	}

	// 2 - manage goroutines concurrency
	nbItem := len(repoList)
	var wgHost sync.WaitGroup             // define a WaitGroup instance for each item in the list : wait for all (concurent) goroutines to complete
	errChItem := make(chan error, nbItem) // define a channel to collect errors from each goroutine

	// 3 - loop over item
	for _, item := range repoList {
		wgHost.Add(1)                  // Increment the WaitGroup:counter for this item
		go func(oneItem lonpm.Repo2) { // create as many goroutine (that will run concurrently) as item AND pass the item as an argument
			defer func() {
				logger.Infof("↩ (%s) %s/%s > finished", phaseName, hostName, oneItem.Name)
				wgHost.Done() // Decrement the WaitGroup counter - when the goroutine complete
			}()
			logger.Infof("↪ (%s) %s/%s > running", phaseName, hostName, oneItem.Name)
			_, grErr := lonpm.AddRepo(hostName, oneItem, logger) // the code to be executed by the goroutine
			if grErr != nil {
				logger.Errorf("(%s) %s/%s > %v", phaseName, hostName, oneItem, grErr) // send goroutines error if any into the chanel
				// send goroutines error if any into the chanel
				errChItem <- fmt.Errorf("%w", grErr)
			}

		}(item) // pass the item to the goroutine
	} // loop

	wgHost.Wait()    // Wait for all goroutines to complete - done with the help of the WaitGroup:counter
	close(errChItem) // close the channel - signal that no more error will be sent

	// 4 - collect errors
	var errList []error
	for e := range errChItem {
		errList = append(errList, e)
	}

	// 5 - handle errors
	nbGroutineFailed := len(errList)
	errCombined := errors.Join(errList...)
	if nbGroutineFailed > 0 {
		logger.Errorf("❌ host: %s > nb node that failed: %d", hostName, nbGroutineFailed)
		return false, errCombined
	}

	// 6 - handle success
	return true, nil
}
